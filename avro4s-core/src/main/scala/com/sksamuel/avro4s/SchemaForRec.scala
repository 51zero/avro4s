package com.sksamuel.avro4s

import java.nio.ByteBuffer
import java.sql.Timestamp
import java.time.{Instant, LocalDate, LocalDateTime, LocalTime, OffsetDateTime}
import java.util.UUID

import magnolia.{CaseClass, Magnolia, SealedTrait, Subtype, TypeName}
import org.apache.avro.util.Utf8
import org.apache.avro.{JsonProperties, LogicalType, LogicalTypes, Schema, SchemaBuilder}
import shapeless.{:+:, CNil, Coproduct}

import scala.language.experimental.macros
import scala.language.implicitConversions
import scala.reflect.ClassTag
import scala.reflect.runtime.universe._
import scala.util.control.NonFatal


/**
  * A [[SchemaForRec]] generates an (recursive) Avro Schema for a Scala or Java type.
  *
  * For example, a String SchemaForRec could return an instance of Schema.Type.STRING
  * or Schema.Type.FIXED depending on the type required for Strings.
  */
abstract class SchemaForRec[T: ClassTag] extends Serializable {
  self =>

  def toSchemaFor(): SchemaFor[T] = new SchemaFor[T] {
    override def schema(fieldMapper: FieldMapper): Schema = self.schema(fieldMapper, Map())
  }

  def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema

  def lookupOrCreate(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema =
    parents.getOrElse(typeClass.runtimeClass, schema(fieldMapper, parents))
    
  val typeClass: ClassTag[T] = implicitly[ClassTag[T]]
  /**
    * Creates a SchemaForRec[U] by applying a function Schema => Schema
    * to the schema generated by this instance.
    */
  def map[U: ClassTag](fn: Schema => Schema): SchemaForRec[U] = new SchemaForRec[U] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema = fn(self.lookupOrCreate(fieldMapper, parents))
  }
}

trait EnumSchemaForRec {

  import scala.collection.JavaConverters._

  protected def addDefault[E](default: E)(schema: Schema): Schema = SchemaBuilder.
    enumeration(schema.getName).
    namespace(schema.getNamespace).
    defaultSymbol(default.toString).
    symbols(schema.getEnumSymbols.asScala.toList:_*)
}

trait LowPrio {
  implicit def fromSchemaFor[T: SchemaFor: ClassTag]: SchemaForRec[T] = new SchemaForRec[T] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema = implicitly[SchemaFor[T]].schema(fieldMapper)
  }
}
object SchemaForRec extends LowPrio {

  import scala.collection.JavaConverters._

  import SchemaFor.{
    arraySchemaFor => _,
    coproductBaseSchema => _,
    coproductSchema => _,
    eitherSchemaFor => _,
    iterableSchemaFor => _,
    listSchemaFor => _,
    mapSchemaFor => _,
    optionSchemaFor => _,
    seqSchemaFor => _,
    setSchemaFor => _,
    tuple2SchemaFor => _,
    tuple3SchemaFor => _,
    tuple4SchemaFor => _,
    tuple5SchemaFor => _,
    gen => _,
    _
  }

  type Typeclass[T] = SchemaForRec[T]

  def apply[T: ClassTag](f: (FieldMapper, Map[Class[_], Schema]) => Schema): SchemaForRec[T] = new SchemaForRec[T] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema = f(fieldMapper, parents)
  }

  def apply[T](implicit SchemaForRec: SchemaForRec[T]): SchemaForRec[T] = SchemaForRec

  implicit def mapSchemaFor[V](implicit SchemaForRec: SchemaForRec[V]): SchemaForRec[Map[String, V]] = {
    new SchemaForRec[Map[String, V]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = SchemaBuilder.map().values(SchemaForRec.lookupOrCreate(fieldMapper, parents))
    }
  }

  implicit def eitherSchemaFor[A, B](implicit leftFor: SchemaForRec[A], rightFor: SchemaForRec[B]): SchemaForRec[Either[A, B]] = {
    new SchemaForRec[Either[A, B]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = SchemaHelper.createSafeUnion(leftFor.lookupOrCreate(fieldMapper, parents), rightFor.lookupOrCreate(fieldMapper, parents))
    }
  }

  implicit def optionSchemaFor[T](implicit SchemaForRec: SchemaForRec[T]): SchemaForRec[Option[T]] = new SchemaForRec[Option[T]] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = {
      val elementSchema = SchemaForRec.lookupOrCreate(fieldMapper, parents)
      val nullSchema = SchemaBuilder.builder().nullType()
      SchemaHelper.createSafeUnion(elementSchema, nullSchema)
    }
  }

  implicit def arraySchemaFor[S: ClassTag](implicit SchemaForRec: SchemaForRec[S]): SchemaForRec[Array[S]] = {
    new SchemaForRec[Array[S]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = Schema.createArray(SchemaForRec.lookupOrCreate(fieldMapper, parents))
    }
  }

  implicit def listSchemaFor[S](implicit SchemaForRec: SchemaForRec[S]): SchemaForRec[List[S]] = {
    new SchemaForRec[List[S]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = Schema.createArray(SchemaForRec.lookupOrCreate(fieldMapper, parents))
    }
  }

  implicit def setSchemaFor[S](implicit SchemaForRec: SchemaForRec[S]): SchemaForRec[Set[S]] = {
    new SchemaForRec[Set[S]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = Schema.createArray(SchemaForRec.lookupOrCreate(fieldMapper, parents))
    }
  }

  implicit def vectorSchemaFor[S](implicit SchemaForRec: SchemaForRec[S]): SchemaForRec[Vector[S]] = {
    new SchemaForRec[Vector[S]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = Schema.createArray(SchemaForRec.lookupOrCreate(fieldMapper, parents))
    }
  }

  implicit def seqSchemaFor[S](implicit SchemaForRec: SchemaForRec[S]): SchemaForRec[Seq[S]] = {
    new SchemaForRec[Seq[S]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = {
        Schema.createArray(SchemaForRec.lookupOrCreate(fieldMapper, parents))
      }
    }
  }

  implicit def iterableSchemaFor[S](implicit SchemaForRec: SchemaForRec[S]): SchemaForRec[Iterable[S]] = {
    new SchemaForRec[Iterable[S]] {
      override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema] = Map()): Schema = Schema.createArray(SchemaForRec.lookupOrCreate(fieldMapper, parents))
    }
  }

  /**
    * Builds an Avro Field with the field's Schema provided by an
    * implicit instance of [[SchemaForRec]]. There must be a instance of this
    * typeclass in scope for any type we want to support in avro4s.
    *
    * Users can add their own mappings for types by implementing a [[SchemaForRec]]
    * instance for that type.
    *
    * @param label   the name of the field as defined in the case class
    * @param annos   the name of the package that contains the case class definition
    * @param default an instance of the Default ADT which contains an avro compatible default value
    *                if such a default applies to this field
    */
  private def buildField[B](label: String,
                            containingNamespace: String,
                            annos: Seq[Any],
                            fieldSchema: Schema,
                            default: Option[B],
                            fieldMapper: FieldMapper,
                            valueTypeDoc: Option[String]): Schema.Field = {

    val extractor = new AnnotationExtractors(annos)
    val doc = extractor.doc.orElse(valueTypeDoc).orNull
    val aliases = extractor.aliases
    val props = extractor.props

    // the name could have been overriden with @AvroName, and then must be encoded with the field mapper
    val name = extractor.name.getOrElse(fieldMapper.to(label))

    // the default value may be none, in which case it was not defined, or Some(null), in which case it was defined
    // and set to null, or something else, in which case it's a non null value
    val encodedDefault: AnyRef = default match {
      case None => null
      case Some(None) => JsonProperties.NULL_VALUE
      case Some(null) => JsonProperties.NULL_VALUE
      case Some(other) => DefaultResolver(other, fieldSchema)
    }

    // if we have annotated with @AvroFixed then we override the type and change it to a Fixed schema
    // if someone puts @AvroFixed on a complex type, it makes no sense, but that's their cross to bear
    val schema = extractor.fixed.fold(fieldSchema) { size =>
      SchemaBuilder.fixed(name).doc(doc).namespace(extractor.namespace.getOrElse(containingNamespace)).size(size)
    }

    // if our default value is null, then we should change the type to be nullable even if we didn't use option
    val schemaWithPossibleNull = if (default.contains(null) && schema.getType != Schema.Type.UNION) {
      SchemaBuilder.unionOf().`type`(schema).and().`type`(Schema.create(Schema.Type.NULL)).endUnion()
    } else schema

    // for a union the type that has a default must be first (including null as an explicit default)
    // if there is no default then we'll move null to head (if present)
    // otherwise left as is
    val schemaWithOrderedUnion = (schemaWithPossibleNull.getType, encodedDefault) match {
      case (Schema.Type.UNION, null) => SchemaHelper.moveNullToHead(schemaWithPossibleNull)
      case (Schema.Type.UNION, JsonProperties.NULL_VALUE) => SchemaHelper.moveNullToHead(schemaWithPossibleNull)
      case (Schema.Type.UNION, defaultValue) => SchemaHelper.moveDefaultToHead(schemaWithPossibleNull, defaultValue)
      case _ => schemaWithPossibleNull
    }

    // the field can override the containingNamespace if the Namespace annotation is present on the field
    // we may have annotated our field with @AvroNamespace so this containingNamespace should be applied
    // to any schemas we have generated for this field
    val schemaWithResolvedNamespace = extractor.namespace
      .map(SchemaHelper.overrideNamespace(schemaWithOrderedUnion, _))
      .getOrElse(schemaWithOrderedUnion)

    val field = encodedDefault match {
      case null => new Schema.Field(name, schemaWithResolvedNamespace, doc)
      case CustomUnionDefault(_, m) =>
        new Schema.Field(name, schemaWithResolvedNamespace, doc, m)
      case CustomEnumDefault(m) =>
          new Schema.Field(name, schemaWithResolvedNamespace, doc, m)
      case CustomUnionWithEnumDefault(_, _, m) => new Schema.Field(name, schemaWithResolvedNamespace, doc, m)
      case _ => new Schema.Field(name, schemaWithResolvedNamespace, doc, encodedDefault)
    }

    props.foreach { case (k, v) => field.addProp(k, v: AnyRef) }
    aliases.foreach(field.addAlias)
    field
  }

  def combine[T: ClassTag](ctx: CaseClass[Typeclass, T]): SchemaForRec[T] = new SchemaForRec[T] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema = {

      val extractor = new AnnotationExtractors(ctx.annotations)
      val doc = extractor.doc.orNull
      val aliases = extractor.aliases
      val props = extractor.props

      val nameExtractor = NameExtractor(ctx.typeName, ctx.annotations)
      val namespace = nameExtractor.namespace
      val name = nameExtractor.name

      val record = Schema.createRecord(name.replaceAll("[^a-zA-Z0-9_]", ""), doc, nameExtractor.namespace, false)
      val newParents = parents + (implicitly[ClassTag[T]].runtimeClass -> record)

      parents.getOrElse(implicitly[ClassTag[T]].runtimeClass, {
        // if the class is a value type, then we need to use the schema for the single field inside the type
        // in other words, if we have `case class Foo(str:String)` then this just acts like a string
        // if we have a value type AND @AvroFixed is present on the class, then we simply return a schema of type fixed
        if (ctx.isValueClass) {
          val param = ctx.parameters.head
          extractor.fixed match {
            case Some(size) =>
              val builder = SchemaBuilder.fixed(name).doc(doc).namespace(namespace).aliases(aliases: _*)
              props.foreach { case (k, v) => builder.prop(k, v) }
              builder.size(size)
            case None => param.typeclass.lookupOrCreate(fieldMapper, newParents)
          }

        } else {
          val fields = ctx.parameters.flatMap { param =>

            val annos = new AnnotationExtractors(param.annotations)

            if (annos.transient) None else {
              val s = param.typeclass.lookupOrCreate(fieldMapper, newParents)
              // if the field is a value type then we may have annotated it with @AvroDoc, and that doc should be
              // placed onto the field, not onto the record type, because there won't be a record type for a value type!
              // magnolia won't give us the type of the parameter, so we must find it in the class type
              val doc = try {
                import scala.reflect.runtime.universe
                val mirror = universe.runtimeMirror(Thread.currentThread().getContextClassLoader)
                val sym = mirror.staticClass(ctx.typeName.full).primaryConstructor.asMethod.paramLists.head(param.index)
                sym.typeSignature.typeSymbol.annotations.collectFirst {
                  case a if a.tree.tpe =:= typeOf[AvroDoc] =>
                    val annoValue = a.tree.children.tail.head.asInstanceOf[Literal].value.value
                    annoValue.toString
                }
              } catch {
                case NonFatal(_) => None
              }

              val default = if (annos.nodefault) None else param.default
              Some(buildField(param.label, namespace, param.annotations, s, default, fieldMapper, doc))
            }
          }

          aliases.foreach(record.addAlias)
          props.foreach { case (k, v) => record.addProp(k: String, v: AnyRef) }
          record.setFields(fields.asJava)
          record
        }
      })
    }
  }

  def dispatch[T: WeakTypeTag: ClassTag](ctx: SealedTrait[Typeclass, T]): SchemaForRec[T] = new SchemaForRec[T] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema = {

      import scala.reflect.runtime.universe

      val runtimeMirror = universe.runtimeMirror(Thread.currentThread().getContextClassLoader)
      val tpe = runtimeMirror.weakTypeOf[T]
      val objs = tpe.typeSymbol.isClass && tpe.typeSymbol.asClass.knownDirectSubclasses.forall(_.isModuleClass)


      val sortedSubtypes = ctx.subtypes.sortWith { (left: Subtype[Typeclass, T], right: Subtype[Typeclass, T]) => 
        val leftPriority: Float = new AnnotationExtractors(left.annotations).sortPriority.getOrElse(0)
        val rightPriority: Float = new AnnotationExtractors(right.annotations).sortPriority.getOrElse(0)
        leftPriority > rightPriority
      }

      if (objs) {
        val symbols = sortedSubtypes.map { sub =>
          val nameExtractor = NameExtractor(sub.typeName, sub.annotations)
          nameExtractor.name
        }
        val nameExtractor = NameExtractor(ctx.typeName, ctx.annotations)

        CustomDefaults.sealedTraitEnumDefaultValue(ctx).map { default =>
          SchemaBuilder.enumeration(nameExtractor.name).defaultSymbol(default).namespace(nameExtractor.namespace).symbols(symbols: _*)
        }.getOrElse(SchemaBuilder.enumeration(nameExtractor.name).namespace(nameExtractor.namespace).symbols(symbols: _*))

      } else {
        val schemas = sortedSubtypes.map(_.typeclass.lookupOrCreate(fieldMapper, parents))
        SchemaHelper.createSafeUnion(schemas: _*)
      }
    }
  }

  def getAnnotationValue[T](annotationClass: Class[T], annotations: Seq[Annotation]): Option[String] = {
    annotations.collectFirst {
      case a: Annotation if a.tree.tpe.typeSymbol.name.toString == annotationClass.getSimpleName => a.tree.children.tail.headOption.flatMap {
        case select: Select => Some(select.name.toString)
        case _ => None
      }
    }.flatten
  }

  // A coproduct is a union, or a generalised either.
  // A :+: B :+: C :+: CNil is a type that is either an A, or a B, or a C.

  // Shapeless's implementation builds up the type recursively,
  // (i.e., it's actually A :+: (B :+: (C :+: CNil)))
  // so here we define the schema for the base case of the recursion, C :+: CNil
  implicit def coproductBaseSchema[S](implicit basefor: SchemaForRec[S]): SchemaForRec[S :+: CNil] = new SchemaForRec[S :+: CNil] {

    import scala.collection.JavaConverters._

    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema = {
      val base = basefor.lookupOrCreate(fieldMapper, parents)
      val schemas = scala.util.Try(base.getTypes.asScala).getOrElse(Seq(base))
      Schema.createUnion(schemas.asJava)
    }
  }

  // And here we continue the recursion up.
  implicit def coproductSchema[S, T <: Coproduct](implicit basefor: SchemaForRec[S], coproductFor: SchemaForRec[T]): SchemaForRec[S :+: T] = new SchemaForRec[S :+: T] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema = {
      val base = basefor.lookupOrCreate(fieldMapper, parents)
      val coproduct = coproductFor.schema(fieldMapper, parents)
      SchemaHelper.createSafeUnion(base, coproduct)
    }
  }

  implicit def tuple2SchemaFor[A, B](implicit a: SchemaForRec[A], b: SchemaForRec[B]): SchemaForRec[(A, B)] = new SchemaForRec[(A, B)] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema =
      SchemaBuilder.record("Tuple2").namespace("scala").doc(null)
        .fields()
        .name("_1").`type`(a.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_2").`type`(b.lookupOrCreate(fieldMapper, parents)).noDefault()
        .endRecord()
  }

  implicit def tuple3SchemaFor[A, B, C](implicit
                                        a: SchemaForRec[A],
                                        b: SchemaForRec[B],
                                        c: SchemaForRec[C]): SchemaForRec[(A, B, C)] = new SchemaForRec[(A, B, C)] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema =
      SchemaBuilder.record("Tuple3").namespace("scala").doc(null)
        .fields()
        .name("_1").`type`(a.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_2").`type`(b.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_3").`type`(c.lookupOrCreate(fieldMapper, parents)).noDefault()
        .endRecord()
  }

  implicit def tuple4SchemaFor[A, B, C, D](implicit
                                           a: SchemaForRec[A],
                                           b: SchemaForRec[B],
                                           c: SchemaForRec[C],
                                           d: SchemaForRec[D]): SchemaForRec[(A, B, C, D)] = new SchemaForRec[(A, B, C, D)] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema =
      SchemaBuilder.record("Tuple4").namespace("scala").doc(null)
        .fields()
        .name("_1").`type`(a.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_2").`type`(b.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_3").`type`(c.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_4").`type`(d.lookupOrCreate(fieldMapper, parents)).noDefault()
        .endRecord()
  }

  implicit def tuple5SchemaFor[A, B, C, D, E](implicit
                                              a: SchemaForRec[A],
                                              b: SchemaForRec[B],
                                              c: SchemaForRec[C],
                                              d: SchemaForRec[D],
                                              e: SchemaForRec[E]): SchemaForRec[(A, B, C, D, E)] = new SchemaForRec[(A, B, C, D, E)] {
    override def schema(fieldMapper: FieldMapper, parents: Map[Class[_], Schema]): Schema =
      SchemaBuilder.record("Tuple5").namespace("scala").doc(null)
        .fields()
        .name("_1").`type`(a.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_2").`type`(b.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_3").`type`(c.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_4").`type`(d.lookupOrCreate(fieldMapper, parents)).noDefault()
        .name("_5").`type`(e.lookupOrCreate(fieldMapper, parents)).noDefault()
        .endRecord()
  }

  implicit def gen[T]: Typeclass[T] = macro Magnolia.gen[T]
}
