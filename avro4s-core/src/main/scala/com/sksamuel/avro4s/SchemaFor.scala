package com.sksamuel.avro4s

import java.nio.ByteBuffer
import java.sql.Timestamp
import java.time.{Instant, LocalDate, LocalDateTime, OffsetDateTime}
import java.util.{Date, UUID}

import org.apache.avro.util.Utf8
import org.apache.avro.{LogicalType, LogicalTypes, Schema, SchemaBuilder}

/**
 * A [[SchemaFor]] generates an Avro Schema for a Scala or Java type.
 *
 * For example, a SchemaFor[String] could return a schema of type Schema.Type.STRING, and
 * a SchemaFor[Int] could return an schema of type Schema.Type.INT
 */
trait SchemaFor[T] {

  def schema[T]: Schema

  /**
   * Changes the type of this SchemaFor to the desired type `U` without any other modifications.
   *
   * @tparam U new type for SchemaFor.
   */
  def forType[U]: SchemaFor[U] = map[U](identity)

  /**
   * Creates a SchemaFor[U] by applying a function Schema => Schema
   * to the schema generated by this instance.
   */
  def map[U](fn: Schema => Schema): SchemaFor[U] = SchemaFor[U](fn(schema))
}

object SchemaFor {

  def apply[T](schema: Schema): SchemaFor[T] = new SchemaFor[T] {
    override def schema[T]: Schema = schema
  }
}

trait BaseSchemas {
  implicit val IntSchemaFor: SchemaFor[Int] = SchemaFor[Int](SchemaBuilder.builder.intType)
  implicit val ByteSchemaFor: SchemaFor[Byte] = IntSchemaFor.forType
  implicit val ShortSchemaFor: SchemaFor[Short] = IntSchemaFor.forType
  implicit val LongSchemaFor: SchemaFor[Long] = SchemaFor[Long](SchemaBuilder.builder.longType)
  implicit val FloatSchemaFor: SchemaFor[Float] = SchemaFor[Float](SchemaBuilder.builder.floatType)
  implicit val DoubleSchemaFor: SchemaFor[Double] = SchemaFor[Double](SchemaBuilder.builder.doubleType)
  implicit val BooleanSchemaFor: SchemaFor[Boolean] = SchemaFor[Boolean](SchemaBuilder.builder.booleanType)
  implicit val ByteBufferSchemaFor: SchemaFor[ByteBuffer] = SchemaFor[ByteBuffer](SchemaBuilder.builder.bytesType)
  implicit val StringSchemaFor: SchemaFor[String] = SchemaFor[String](SchemaBuilder.builder.stringType)
  implicit val Utf8SchemaFor: SchemaFor[Utf8] = StringSchemaFor.forType
  implicit val CharSequenceSchemaFor: SchemaFor[CharSequence] = StringSchemaFor.forType
  implicit val UUIDSchemaFor: SchemaFor[UUID] = SchemaFor[UUID](LogicalTypes.uuid().addToSchema(SchemaBuilder.builder.stringType))
}

object TimestampNanosLogicalType extends LogicalType("timestamp-nanos") {
  override def validate(schema: Schema): Unit = {
    super.validate(schema)
    if (schema.getType != Schema.Type.LONG) {
      throw new IllegalArgumentException("Logical type timestamp-nanos must be backed by long")
    }
  }
}

object OffsetDateTimeLogicalType extends LogicalType("datetime-with-offset") {
  override def validate(schema: Schema): Unit = {
    super.validate(schema)
    if (schema.getType != Schema.Type.STRING) {
      throw new IllegalArgumentException("Logical type iso-datetime with offset must be backed by String")
    }
  }
}
trait DateSchemas {
  implicit val InstantSchemaFor: SchemaFor[Instant] = SchemaFor[Instant](LogicalTypes.timestampMillis().addToSchema(SchemaBuilder.builder.longType))
  implicit val DateSchemaFor: SchemaFor[Date] = SchemaFor(LogicalTypes.date().addToSchema(SchemaBuilder.builder.intType))
  implicit val LocalDateSchemaFor: SchemaFor[LocalDate] = DateSchemaFor.forType
  implicit val LocalDateTimeSchemaFor: SchemaFor[LocalDateTime] = SchemaFor(TimestampNanosLogicalType.addToSchema(SchemaBuilder.builder.longType))
  implicit val OffsetDateTimeSchemaFor: SchemaFor[OffsetDateTime] = SchemaFor(OffsetDateTimeLogicalType.addToSchema(SchemaBuilder.builder.stringType))
  implicit val LocalTimeSchemaFor: SchemaFor[Nothing] = SchemaFor(LogicalTypes.timeMicros().addToSchema(SchemaBuilder.builder.longType))
  implicit val TimestampSchemaFor: SchemaFor[Timestamp] = SchemaFor[Timestamp](LogicalTypes.timestampMillis().addToSchema(SchemaBuilder.builder.longType))
}

trait ByteIterableSchemaFors {
  implicit val ByteArraySchemaFor: SchemaFor[Array[Byte]] = SchemaFor[Array[Byte]](SchemaBuilder.builder.bytesType)
  implicit val ByteListSchemaFor: SchemaFor[List[Byte]] = ByteArraySchemaFor.forType
  implicit val ByteSeqSchemaFor: SchemaFor[Seq[Byte]] = ByteArraySchemaFor.forType
  implicit val ByteVectorSchemaFor: SchemaFor[Vector[Byte]] = ByteArraySchemaFor.forType
}
