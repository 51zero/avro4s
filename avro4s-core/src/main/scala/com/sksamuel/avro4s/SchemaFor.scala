package com.sksamuel.avro4s

import com.sksamuel.avro4s.SchemaUpdate.{FullSchemaUpdate, NoUpdate}
import org.apache.avro.{Schema, SchemaBuilder}

import scala.language.experimental.macros
import scala.language.implicitConversions
import scala.reflect.ClassTag
import scala.reflect.runtime.universe._

/**
  * A [[SchemaFor]] generates an Avro Schema for a Scala or Java type.
  *
  * For example, a String SchemaFor could return an instance of Schema.Type.STRING
  * or Schema.Type.FIXED depending on the type required for Strings.
  */
trait SchemaFor[T] extends Resolvable[SchemaFor, T] with Serializable {
  self =>

  def apply(env: DefinitionEnvironment[SchemaFor], update: SchemaUpdate): SchemaFor[T] =
    (self, update) match {
      case (unresolved: ResolvableSchemaFor[T], _) => unresolved.resolve(env, update)
      case (_, FullSchemaUpdate(sf))               => sf.forType
      case _                                       => self
    }

  def schema: Schema
  def fieldMapper: FieldMapper

  /**
    * Creates a SchemaFor[U] by applying a function Schema => Schema
    * to the schema generated by this instance.
    */
  def map[U](fn: Schema => Schema): SchemaFor[U] = SchemaFor[U](fn(schema), fieldMapper)

  def forType[U]: SchemaFor[U] = map[U](identity)
}

trait ResolvableSchemaFor[T] extends SchemaFor[T] {
  def resolve(env: DefinitionEnvironment[SchemaFor], update: SchemaUpdate): SchemaFor[T]

  lazy val adhocInstance = resolve(DefinitionEnvironment.empty, NoUpdate)

  def schema = adhocInstance.schema
  def fieldMapper: FieldMapper = adhocInstance.fieldMapper
}

case class ScalePrecision(scale: Int, precision: Int)

object ScalePrecision {
  implicit val default = ScalePrecision(2, 8)
}

trait EnumSchemaFor {

  import scala.collection.JavaConverters._

  protected def addDefault[E](default: E)(schema: Schema): Schema =
    SchemaBuilder
      .enumeration(schema.getName)
      .namespace(schema.getNamespace)
      .defaultSymbol(default.toString)
      .symbols(schema.getEnumSymbols.asScala.toList: _*)
}

object JavaEnumSchemaFor extends EnumSchemaFor {

  def apply[E <: Enum[_]](default: E)(implicit tag: ClassTag[E]): SchemaFor[E] =
    SchemaFor.javaEnumSchemaFor.map[E](addDefault(default))
}

object ScalaEnumSchemaFor extends EnumSchemaFor {

  def apply[E <: scala.Enumeration#Value](default: E)(implicit tag: TypeTag[E]): SchemaFor[E] =
    SchemaFor.scalaEnumSchemaFor.map[E](addDefault(default))
}

object SchemaFor
    extends MagnoliaDerivedSchemaFors
    with ShapelessCoproductSchemaFors
    with CollectionAndContainerSchemaFors
    with TupleSchemaFors
    with BaseSchemaFors {

  // the following four implicits have to be here directly in order to avoid ambiguous implicit values errors

  implicit val ByteArraySchemaFor: SchemaFor[Array[Byte]] = SchemaFor[Array[Byte]](SchemaBuilder.builder.bytesType)
  implicit val ByteListSchemaFor: SchemaFor[List[Byte]] = ByteArraySchemaFor.forType
  implicit val ByteSeqSchemaFor: SchemaFor[Seq[Byte]] = ByteArraySchemaFor.forType
  implicit val ByteVectorSchemaFor: SchemaFor[Vector[Byte]] = ByteArraySchemaFor.forType

  def apply[T](schema: Schema, fieldMapper: FieldMapper = DefaultFieldMapper) = {
    val s = schema
    val fm = fieldMapper
    new SchemaFor[T] {
      def schema: Schema = s
      def fieldMapper: FieldMapper = fm
    }
  }

  def apply[T](implicit schemaFor: SchemaFor[T]): SchemaFor[T] = schemaFor.apply()
}
